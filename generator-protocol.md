# Python 生成器与协程的不同

- 迭代器(Iterator)与可迭代对象(Iterable)
- 迭代器的工作原理
- 生成器函数的工作原理
- 生成器的惰性体现
- 生成器表达式
- yield关键字在生成器与协程中的区别以及yield本质
- 协程之精髓send方法
- 协程的实现的必要条件
- yield from 句法以及原理
- 生成器的三种不同代码编写风格

1. 迭代器与可迭代对象
+ Iterator与Iterable抽象基类；
+ Iterable.\_\_iter\_\_方法返回一个Iterator实例对象；
+ Iterator类必须实现\_\_next\_\_方法
+ Iterator.\_\_iter\_\_方法直接返回实例本身
+ 可迭代对象与迭代器的关系:Python从可迭代对象中获取迭代器
+ 迭代器(Iterator)的两个方法
  - \_\_next\_\_:返回迭代器中的下一个可用的元素，如果没有元素抛出异常
  - \_\_iter\_\_:返回self，以便在使用可迭代对象的地方使用迭代器。
+ 可迭代对象(Iterable)的接口方法
  - \_\_iter\_\_抽象方法,返回迭代器对象
+ 疑问：迭代器继承可迭代对象，实现了可迭代对象的iter方法，并实现了自身的next方法？迭代器设计模式？

2. 迭代器的工作原理：
可迭代对象有个\_\_iter\_\_方法，每次都实例化一个新的迭代器对象，而迭代器要实现\_\_next\_\_返回单个元素，此外还要实现\_\_iter\_\_方法，返回迭代器本身。

序列传入iter()函数，序列变为可迭代对象，返回迭代器，迭代器在可迭代对象使用的时候被使用。

所以可迭代对象与迭代器之间是一种代理模式？

所以可迭代对象与生成器之间是一种代理模式？

以上两者的内存结构牵扯的是否为副本机制？因为遍历也只是读内存？传入对象变量就会发生拷贝现象，而地址不会，数据操作同一份？

3. 生成器的工作原理

   在Python中函数体内有yield关键字，该函数就是生成器函数，调用生成器函数返回一个生成器对象。也就是生成器函数是生成器的工厂。

   与使用迭代器的语法区别: 可迭代对象的\_\_iter\_\_方法中是否有yield。
   与使用迭代器的本质区别: 迭代器的实现没有变
   与使用迭代器返回值区别：迭代器返回一个元素对象，生成器返回生成器对象(地址)
   与使用迭代器传参区别: 使用迭代器的时候给迭代器传入的是对象实例，使用生成器函数返回的是地址，传入next的是地址引用。(是否与C++中传参对象与传参引用相同？)

4. 生成器的惰性体现
   
   可迭代对象的\_\_iter\_\_中被循环的对象上。

5. 生成器表达式

   类似于列表推导,不同的是生成器表达式是圆括号,生成器表达式返回生成器对象

6. yield关键字在生成器与协程中的区别以及yield本质

yield作为动词有两个意思：产出和让步。

对于Python生成器中的yield来说，这个两个含义都成立。yield item这行代码产出一个值，提供给next()的调用方，此外还会做出让步，暂停执行生成器，让调用方继续工作，知道需要使用另一个值再调用next()。调用方会从生成器中拉取值。

从句法上看协程与生成器类似，都是定义体中包含yield关键字的函数。可是在协程中yield通常出现在表达式的右边,如(tmp=yield)，可以产出值，也可以不产出值，如果yield关键字后面没有表达式，那么生成器产出None。协程可能会从调用方接收数据，不过调用方把数据提供给协程使用的是send()方法，而不是next()函数。通常，调用方会把值推送给协程。

yield关键字甚至还可以不接收或传出数据。不管数据如何流动，yield都是一种流程控制工具，使用它可以实现协作式多任务。协程可以把控制器让步给中心调度程序，从而激活其它的协程。

从根本上把yield视作控制流程的方式，这样就好理解协程了。

7. 协程之精髓send方法

   send方法使得生成器前进到下一个yield语句。send还允许使用生成器的客户把数据发给自己，
   send方法参数成为生成器函数定义体中对应的yield表达式的值。也就是说send()方法允许在客户代码与生成器之间双向数据交换。而next方法只允许客户从生成器中获取数据。

   协程与迭代无关。

8. 协程的实现的必要条件

   next方法预激，没有预激的协程不能工作。

9. yield from 句法

是嵌套yield的缩写。

yield from <iterable>,调用iter(x),获取迭代器
yield from <iterable>表达式生成器函数(子生成器函数)

- 调用方
- 委派生成器(含yield from)
- 子生成器(含yeild)，也可是是只实现了next的迭代器

调用方调用委派生成器，记录委派生成器的返回值，到委派生成器的yield from暂停，激活子生成器，并架设调用方与子生成器之间的通道，子生成器等待调用方把值通过send方法传给子生成器,
子生成器运行完把值yield返回给调用方,yield from恢复工作，一直往复进行。
调用方需要在每个yield from结束后把委派生成器send(None),结束子生成器的工作，并且以保证下一组处理。

委派生成器的send方法发送值都是给子生成器。如果发送的是None，那么会调用子生成器的next方法，如果发送的不是None，则调用子生成器的send方法。

10. 生成器的三种不同代码编写风格
- 拉取式：迭代器
- 推送式：协程
- 任务式：多任务协作

## 协程与普通函数的异同
+ 相同点：
  都使用def关键字定义

+ 不同点：
  - 协程中有yield，普通函数没有
  - 普通函数可以被直接调用，协程不能被直接调用