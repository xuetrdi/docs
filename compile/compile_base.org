* 编译原理
  
** 编译原理的前端知识
*** 词法分析
    把程序分割成一个个 Token 的过程，可以通过构造有限自动机来实现
*** 语法分析
    把程序的结构识别出来，并形成一颗便于由计算机处理的抽象语法树(AST)。可以用递归下降的算法来实现。
*** 语义分析
    消除语义模糊，生成一些属性信息，让计算机能够依据这些信息生成目标代码。

** 作用域(Scope)和生命期(Extent)
*** 实现函数功能、面向对象功能、闭包功能
    - 如果要实现函数功能，要升级变量管理机制
    - 引用作用域机制，来保证变量的引用指向正确的变量定义
    - 提升变量存储机制，不能只把变量和它的值简单扔到一个 HashMap 里,要管理它的生存期,减少对内存的占用
    - 可以帮助深入理解函数、块、闭包、面向对象、静态成员、本地变量、全局变量
    - 了解`作用域`与`生存期`在`编译期`和`运行期`的机制之后，就能解决在学习过程中遇到的问题
    - 为什么需要栈和堆两种机制来管理内存
    - 变量的生存期跟作用域是一致的，出了作用域生存期也就结束了，变量所占的内存也就释放了
    - 作用域和生存期是计算机语言更加基础的概念，其实是因为它们对应到了``运行``时的内存管理的基本机制
*** 作用域(空间)
    - 对作用域的分析就是`语义分析`的任务之一
    - 三种作用域: 块作用域(Block)、函数作用域(Function)、类作用域(Class)
*** 生存期(时间)
    - 生存期是变量可以访问的时间段，也就是从分配内存给它，到收回它的内存之间的时间
*** 变量
    - 作用域与生存期一致，出了作用域，生存期也就结束了。这是本地变量的标准特征，这些本地变量使用栈来管理的
    - 变量的生存期跟语法上的作用域不一致，比如在堆中申请的内存，退出作用域后仍然会存在
    - 如果变量存在多个作用域，就需要设计一个数据结构来区分变量的作用域
    - 作用域是一个树状的结构，森林结构(面向对象)
*** 栈帧(Stack Frame)
    - 代码执行时进入和退出一个个作用域的过程可以用栈来实现
    - 每进入一个作用域，就往栈帧里压入一个数据结构，这个数据结构叫做栈帧
    - 栈帧能够保存当前作用域的所有变量的值，当退出这个作用域的时候，这个栈帧就被弹出，里面的变量就失效了
*** 函数调用
    - 建立一个栈帧
    - 计算所有参数的值，并放入栈帧
    - 执行函数声明中的函数体
*** 面向对象
    - 从类型、作用域和生存期的角度进行重新解读，这样能够更好地把握面向对象的本质特征
*** 闭包(Closure)
    作者认为是为了让函数能够在这种情况下继续运行所提供的一个方案
    让函数成为一等公民
** 作用域
*** 静态作用域(Static Scope)
    符号之间的引用关系能够根据程序代码在编译时就能确定，在运行时不会变
    某个函数时在哪儿声明的，就具有它所在位置的作用域，它能够哪些变量，那么就跟这些变量绑定了，在运行时就一直访问这些变量。
    
    静态作用域可以由程序代码决定，在编译时就能完全确定，所以又叫词法作用域(Lexcical Scope)
    这里的 Lexcical 相对应的词汇可以认为是 Runtime，一个是编写时，一个是运行时。
    
    用静态作用域的概念描述一下闭包，我们可以说：因为我们的语言是静态作用域的，它能够访问的变量，需要一直都能访问，为此，需要把某些不变量的生存期延长。
*** 动态作用域(Dynamic Scope)
    变量引用跟变量声明不在编译时就绑定死了，在运行时，它是在运行环境中动态地找一个相同名称的变量。
** 类型系统
*** 静态类型语言
    全部或者几乎全部的类型检查是在编译期进行的
*** 动态类型语言
    类型的检查是运行期进行的
*** 类型检查(Type Checking)
    
*** 类型推导(Type Inference)
    S 属性(Synthesized Attribute)
    - 通过下级节点和自身节点来确定
    I 属性(Inherited Attribute)
    - 某个节点由上级节点、兄弟节点、和自身来决定的

*** 类型转换(Type Conversion)
** 语义分析场景: 引用消解
   在程序里使用变量、函数、类等符号时，我们需要知道它们指的是谁，要等对应到定义它们的地方。
   另一方面，当我们重构一个变量名称、方法名称或类名称的时候，所有引用它的地方都会同步修改。
   IDE 分析了符号之间的交叉引用关系
   
   函数的引用消解比变量的引用消解还要更复杂一些。
   - 函数名称
   - 参数
   - 返回值
   在面向对象编程语言中，函数引用的消解也很复杂。
   在 C++语言中，引用的消解还要更加复杂
   命名空间也是做引用消解的时候需要考虑的因素
*** 命名空间
    引用消解可能会产生几个结果
    - 解析出了准确的引用关系
    - 重复定义(在声明新的符号的时候，发现这个符号已经被定义过了)
    - 引用失败(找不到某个符号的定义)
    - 如果两个不同的命名空间中都有相同名称的符号，编程者需要明确指定
** 语义分析场景：左值和右值
   - 赋值表达式的左边
   - 带有初始化的变量声明语句中的变量
   - 当给函数形参赋值的时候
   - 一元操作符: ++ 和--
   - 其它需要改变变量内容的操作
** 如何做属性计算
   属性计算是做上下文分析，或者说语义分析是一种算法
   按照属性计算的视角，我们之前所处理的各种语义分析问题，都可以看做是对 AST 节点的某个属性进行计算。
   针对求左值场景中的 primary 节点，它需要计算的属性包括:
   - 它的变量定义是哪个
   - 它的类型是什么
   - 它的作用域是什么
   - 这个节点求值时，是否该返回左值？能否正确地返回一个左值？
   - 它的值是什么
   属性计算需要用到属性文法。在词法、语法分析阶段，我们分别学习了正则文法和上下无关文法，在语义分析阶段我们要了解的是属性文法(Attribute Grammar)
   属性计算的特点:
   - 它会基于语法规则，增加一些语义处理有关的规则。
   - 语法制导的定义(Syntax directed definition): SDD
   - 语法制导的翻译(Syntax directed translation): SDT
** 语义分析过程拆成了好几个任务，对 AST 做了多次遍历
   第一遍: 类型和作用域解析(TypeAndScope)
   第二遍: 类型的消解(TypeResolver)
   第三遍: 引用的消解和 S 属性的类型推导(RefResolver)
   第四遍: 做类型检查(TypeChecker)
   第五遍: 做一些语义合法性的检查(SematicValidator)
** 语义分析小结
   - 语义分析的本质是对上下文相关情况的处理，能做词法分析和语法分析所做不到的事情
   - 了解引用消解，左值和右值的场景，可以增加对语义分析的直观理解
   - 掌握属性计算和属性文法，可以使我们用更加形式化、更清晰的算法来完成语义分析的任务
** 继承和多态语义分析
*** 子类型
    放宽类型的检查，能用子类代替父类，从而导致多态
    实现方式有两种：
    - 名义子类型(Nominal Subtyping): 显示声明继承了什么类
    - 结构化子类型(Structural Subtyping): Duck Type, 不需要显式说自己是什么类型，只要它实现了某个类型的所有方法，那就是这个类型
*** 从类型体系的角度理解继承和多态
    - 继承的意思是一个类的子类，自动具备了父类的属性和方法，除非被父类声明为私有的
    - 多态的意思是同一个类的不同子类，在调用同一个方法时会执行不同的动作
*** 如何对继承和多态的特性做语义分析
    1. 从类型处理角度出发，我们要识别出新的类型：Mammal、Cow、Sheep，之后，就可以用它们的声明变量
    2. 我们要设置正确的作用域
    3. 要对变量和函数做类型的引用消解
*** 如何在运行期实现方法的动态绑定
    只有了解运行期都发生了什么，才能知道继承和多态是怎么发生的
*** 继承情况下对象的实例化
    在存在继承关系的情况下，创建对象时，不仅要初始化自己这一级的属性变量，还要把各级父类的属性变量也都初始化。
*** 如何实现 this 和 super
    继承和多态在编译期和运行期的特性。
    - 成员变量的作用域
    - 多态
    - 对象初始化
*** 小结
    - 从类型角度，面向对象的继承和多态是一种叫做子类型的现象，子类型能够放宽对类型检查，从而支持多态
    - 在编译期，无法准确地完成对象方法和属性的消解，因为无法确切知道对象的子类型
    - 在运行期，我们能够获得对象的确切的子类型信息，从而绑定正确的方法和属性，实现继承和多态。另一个需要注意的运行期的特征，是对象的逐级初始化过程。
