* 编译原理
  
** 编译原理的前端知识
*** 词法分析
    把程序分割成一个个 Token 的过程，可以通过构造有限自动机来实现
*** 语法分析
    把程序的结构识别出来，并形成一颗便于由计算机处理的抽象语法树(AST)。可以用递归下降的算法来实现。
*** 语义分析
    消除语义模糊，生成一些属性信息，让计算机能够依据这些信息生成目标代码。

** 作用域(Scope)和生命期(Extent)
*** 实现函数功能、面向对象功能、闭包功能
    - 如果要实现函数功能，要升级变量管理机制
    - 引用作用域机制，来保证变量的引用指向正确的变量定义
    - 提升变量存储机制，不能只把变量和它的值简单扔到一个 HashMap 里,要管理它的生存期,减少对内存的占用
    - 可以帮助深入理解函数、块、闭包、面向对象、静态成员、本地变量、全局变量
    - 了解`作用域`与`生存期`在`编译期`和`运行期`的机制之后，就能解决在学习过程中遇到的问题
    - 为什么需要栈和堆两种机制来管理内存
    - 变量的生存期跟作用域是一致的，出了作用域生存期也就结束了，变量所占的内存也就释放了
    - 作用域和生存期是计算机语言更加基础的概念，其实是因为它们对应到了``运行``时的内存管理的基本机制
*** 作用域(空间)
    - 对作用域的分析就是`语义分析`的任务之一
    - 三种作用域: 块作用域(Block)、函数作用域(Function)、类作用域(Class)
*** 生存期(时间)
    - 生存期是变量可以访问的时间段，也就是从分配内存给它，到收回它的内存之间的时间
*** 变量
    - 作用域与生存期一致，出了作用域，生存期也就结束了。这是本地变量的标准特征，这些本地变量使用栈来管理的
    - 变量的生存期跟语法上的作用域不一致，比如在堆中申请的内存，退出作用域后仍然会存在
    - 如果变量存在多个作用域，就需要设计一个数据结构来区分变量的作用域
    - 作用域是一个树状的结构，森林结构(面向对象)
*** 栈帧(Stack Frame)
    - 代码执行时进入和退出一个个作用域的过程可以用栈来实现
    - 每进入一个作用域，就往栈帧里压入一个数据结构，这个数据结构叫做栈帧
    - 栈帧能够保存当前作用域的所有变量的值，当退出这个作用域的时候，这个栈帧就被弹出，里面的变量就失效了
*** 函数调用
    - 建立一个栈帧
    - 计算所有参数的值，并放入栈帧
    - 执行函数声明中的函数体
*** 面向对象
    - 从类型、作用域和生存期的角度进行重新解读，这样能够更好地把握面向对象的本质特征
*** 闭包(Closure)
    作者认为是为了让函数能够在这种情况下继续运行所提供的一个方案
    让函数成为一等公民
** 作用域
*** 静态作用域(Static Scope)
    符号之间的引用关系能够根据程序代码在编译时就能确定，在运行时不会变
    某个函数时在哪儿声明的，就具有它所在位置的作用域，它能够哪些变量，那么就跟这些变量绑定了，在运行时就一直访问这些变量。
    
    静态作用域可以由程序代码决定，在编译时就能完全确定，所以又叫词法作用域(Lexcical Scope)
    这里的 Lexcical 相对应的词汇可以认为是 Runtime，一个是编写时，一个是运行时。
    
    用静态作用域的概念描述一下闭包，我们可以说：因为我们的语言是静态作用域的，它能够访问的变量，需要一直都能访问，为此，需要把某些不变量的生存期延长。
*** 动态作用域(Dynamic Scope)
    变量引用跟变量声明不在编译时就绑定死了，在运行时，它是在运行环境中动态地找一个相同名称的变量。
