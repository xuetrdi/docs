============
Golang
============

并发与分布式
------------

* 并发执行的-执行体-
* 执行体之间的互斥与同步
* 执行体之间的消息传递
  
1. 执行体之间的互斥与同步

   * 执行体之间存在共享资源(共享内存)，为了确保内存访问的确定性，需要对访问该共享资源的相关操作进行互斥。
   * 当多个执行体之间的逻辑存在时序上的依赖时，也往往需要在执行体之间进行同步。

2. 执行体之间的消息传递
   
   * 在并发模型的选择上，有两个流派，一是共享内存，一是消息传递模型。
   * Go语言采用Erlang风格的并发模型-消息传递模型，通道(channel)

3. 编程哲学
   
   * Go语言反对函数和操作符重载
   * Go支持类，类成员方法，类组合
   * 反对继承，反对虚函数，反对虚函数重载
   * Go语言放弃了构造函数和析构函数
   * Go语言提供非侵入式接口interface
   * 在Go语言中，只要两个接口拥有相同的方法列表，那么它们就是等同的。可以相互赋值。
     
4. 变量类型
   
   * 布尔类型 bool
   * 整型 int8,byte,int16,int,uint,uintptr
   * 浮点类型float32,float64
   * 复数类型 complex64,complex128
   * 字符串string
   * 字符类型rune
   * 错误类型error
   * 指针pointer
   * 数组array
   * 切片slice
   * 字典map
   * 通道chan
   * 结构体struct
   * 接口interface

6. 变量初始化
7. 变量赋值
8. 常量e
   
9. Go语言字符类型分为两类

    * byte:代表UTF8字符串的单个字节的值(字节)
    * rune:代表单个Unicode字符(字符)
  
10. Go语言数据
  
    * 一系列同一类型的数据集合。
    * 声明:[10] int
    * 数组的长度:len(arr),定义后不能更改
    * 作为函数参数,传入了数组的副本(值传递)

11. 数组切片
  
    * 一个指向原生数组的指针
    * 数组切片中的元素个数
    * 数组切片已分配的存储空间
    * 创建数组切片
   
      * 基于数组
      * 直接创建
  
    * 元素的遍历
   
      * len(slice)
      * range slice
  
    * 动态增减元素

12. map
  
    * 变量声明: var pmap map[string] PersonInfo
    * 创建:    pmap = make(map[string] PersonInfo)
    * 元素赋值: pmap["9527"] = PersonInfo{"9527","Roc","ROOM 100"}
    * 元素删除: delete(pmap, "9527")
    * 元素查找:value, ok := pmap["9527"]

13. 函数
  
    * 不定参数
    
      * 不定参数类型(个数不定，类型确定)
      * 不定参数的传递(不定参数传入外层函数，再传入内层函数)
      * 任意类型的不定参数(interface{})
  
    * 多返回值
    * 匿名函数与闭包,可以赋值给变量，也可以直接执行
    
14. 错误处理
  
    * defer语句释放资源
    * panic()报告运行时的错误
    * recover()处理运行时的错误
    
15. 主程序
    
    * 获取并解析命令行输入
    * 从对应文件中读取输入数据
    * 调用对应的排序函数
    * 将排序结果输出到对应文件中
    * 打印排序所花费的时间


===================
第三章 面向对象编程
===================
    


===================
第四章 并发编程
===================

===================
第五章 网络编程
===================

===================
第六章 安全编程
===================


===================
第七章 工程管理
===================

